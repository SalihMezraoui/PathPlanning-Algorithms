\chapter{Optimierungsstrategien}

In diesem Kapitel wird beschrieben, wie bisher vorgestellten Algorithmen zur Pfadplanung optimiert werden können.

\section{Bidirektionale Suche}

Bei der bidirektionalen Suche wird ein Suchalgorithmus simultan aus zwei Richtungen laufen gelassen – vom Startknoten zum Zielknoten und umgekehrt. Der Suchalgorithmus wird bei diesem Vorgehen so modifiziert, dass die Abbruchbedingung dann eintritt, wenn beide Suchen denselben Knoten expandieren. Somit betrachtet jede der beiden Suchen nur die Hälfte des Graphen, was in einer Reduktion der Zeitkomplexität resultiert \cite{Russell2010}. Es ist jedoch zu beachten, dass die Platzkomplexität stark ansteigt, da in beiden Suchen eigene Priority-Queues verwaltet werden müssen. Außerdem ist es für viele Problemstellungen keinesfalls trivial, eine Suche rückwärts durchzuführen, da eine Methode zur Berechnung des Vorgängers eines Knotens gegeben sein muss \cite{Russell2010}.

Eine Implementierung der Bidirektionalen Suche ist der Bidirektionale Dijkstra Algorithmus von Vaira und Kurasova. [7] Hier wird der in Abschnitt \ref{Algorithmen zur Pfadplanung} vorgestellte Dijkstra Algorithmus so modifiziert, dass eine bidirektionale Suche von zwei Prozessen auf einem Mehrkernprozessor parallelisiert durchgeführt wird. In mehreren experimentellen Analysen konnte gezeigt werden, dass die Laufzeit des parallelen bidirektionalen Dijkstra Algorithmus bis zu drei Mal kleiner ist als die des Standard Dijkstra Algorithmus.

\section{Informed Search}
Ein Ansatz, um effizienter Lösungen für das Shortest Path Problem zu finden, ist die Informed Search Strategie, bei der problemspezifisches Wissen, das über die Definition des Problems hinausgeht, bei der Lösungsfindung berücksichtigt wird. Der nächste zu expandierende Knoten auf dem Pfad zum Zielknoten wird auf Basis einer Bewertungsfunktion $f(n)$ ausgewählt. Eine Komponente dieser Bewertungsfunktion ist eine heuristische Funktion $h(n)$, die die zu erwartenden Kosten des optimalen Pfades vom Knoten n zum Zielknoten berechnet \cite{Russel2010}. Im Falle des Straßennetzes könnte hierzu die Länge der Luftlinie zwischen dem Knoten n und dem Zielknoten verwendet werden \cite{Hart1968}.

Die einfachste Umsetzung dieser Strategie ist, nur die heuristische Funktion bei der Bewertung von Knoten heranzuziehen, sodass $f(n)=h(n)$ gilt. Dieses Vorgehen wird auch Greedy Best-First Suche genannt, da in jedem Schritt versucht wird, so nahe wie möglich an den Zielknoten zu gelangen \cite{Russel2010}. Auf diese Weise werden die Suchkosten, also die Anzahl der expandierten Knoten zwar minimiert, es kann jedoch nicht garantiert werden, dass die gefundene Lösung optimal ist \cite{Heusner2017}.

Eine elaboriertere Umsetzung der Informed Search Strategie ist der A*-Algorithmus zur Berechnung des kürzesten Pfades zwischen zwei Knoten \cite{Russel2010}. A* basiert auf Dijkstra’s Algorithmus und erweitert diesen um eine heuristische Funktion, um die Laufzeit zu reduzieren \cite{Peralta2020}. Die Bewertungsfunktion $f(n)$ für den A*-Algorithmus setzt sich zusammen aus den Kosten des optimalen Pfades vom Startknoten bis zum Knoten n, $g(n)$ und einer heuristischen Funktion $h(n)$, sodass gilt:
\begin{align}
	f(n)=g(n)+h(n)
\end{align}

Da verschiedene Heuristiken zur Konstruktion von h(n) gewählt werden können, stellt A* streng genommen eine Familie von Algorithmen dar, wobei die Wahl einer Funktion h(n) einen spezifischen Algorithmus der Familie selektiert \cite{Hart1968}. 
Hart, Nilsson und Raphael, die in \cite{Hart1968} die A*-Suche 1968 zum ersten Mal beschrieben haben, konnten nachweisen, dass A* vollständig und optimal ist, wenn die gewählte Heuristik zulässig und konsistent ist. Das heißt, dass unter den angegebenen Voraussetzungen für die Heuristik, immer ein Pfad vom Start- zum Zielknoten gefunden wird (sofern dieser existiert) und dass dieser Pfad in jedem Fall optimal ist. Des Weiteren konnte gezeigt werden, dass A* optimal effizient ist – es kann also keinen anderen optimalen Algorithmus geben, der garantiert weniger Knoten expandiert als A* \cite{Russel2010}.


